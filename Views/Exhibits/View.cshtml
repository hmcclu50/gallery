@model farris_art_gallery.Models.Exhibit

@{
    ViewData["Title"] = "Details";
}

<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
<script type="importmap">
    {
        "imports": {
        "three": "https://unpkg.com/three@0.142.0/build/three.module.js"
        }
    }
</script>

<style>
    .full-screen {
        position: absolute;
        left: 0;
        right: 0;
        top: 56px;
        bottom: 0;
    }
</style>

<div id="webglviewer" class="full-screen"></div>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'https://unpkg.com/three@0.142.0/examples/jsm/controls/OrbitControls.js';
    
    // tracker variables
    
    @{
        int? position = 0;
    }
    
    // initializing renderer
    
    var renderer = new THREE.WebGLRenderer();
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('webglviewer').appendChild(renderer.domElement);
    
    // initializing scene and camera
    
    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        1,
        1000000
    );
    camera.position.set(0, 0, 0);
    camera.lookAt(-10, 0, 0);
    
    // setting up mouse controls
    
    var controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(camera.position.x + .1, camera.position.y, camera.position.z);
    controls.rotateSpeed = -0.15;
    controls.enableDamping = true;
    
    animate();
        
    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }    
    
    // initialize navigation buttons
    
    var navigationMaterial = new THREE.MeshBasicMaterial({
        color: 0xffff00
    });
    var navigationGeometry = new THREE.SphereBufferGeometry(0.15, 32, 32);
    
    var navigationForward = new THREE.Mesh(navigationGeometry, navigationMaterial);
    var navigationBackward = new THREE.Mesh(navigationGeometry, navigationMaterial);
    var navigationLeft = new THREE.Mesh(navigationGeometry, navigationMaterial);
    var navigationRight = new THREE.Mesh(navigationGeometry, navigationMaterial);
    
    navigationForward.position.set(-2.5,-1,0);
    navigationBackward.position.set(2.5,-1,0);
    navigationLeft.position.set(0,-1,2.5);
    navigationRight.position.set(0,-1,-2.5);
    
    var hasForward = @(Model.Images.FirstOrDefault(i => i.Position == position).Forward != null)
    var hasBackward = @(Model.Images.FirstOrDefault(i => i.Position == position).Backward != null)
    var hasLeft = @(Model.Images.FirstOrDefault(i => i.Position == position).Left != null)
    var hasRight  = @(Model.Images.FirstOrDefault(i => i.Position == position).Right != null)
    
    if (!hasForward) navigationForward.visible = false;
    if (!hasBackward) navigationBackward.visible = false;
    if (!hasLeft) navigationLeft.visible = false;
    if (!hasRight) navigationRight.visible = false;
    
    scene.add(navigationForward);
    scene.add(navigationBackward);
    scene.add(navigationLeft);
    scene.add(navigationRight);
    
    // creating image viewer and adding initial background
    
    var backgroundUrl = '@("/img/" + Model.Images.FirstOrDefault(i => i.Position == position).ImageName)'; // initializes to position 0
        
    function loadSphere(url){
      var loader = new THREE.TextureLoader();
      loader.load(
          url,
          function (texture) {
              var sphereMaterial = new THREE.MeshBasicMaterial({
                  map: texture
              });
              var sphereGeometry = new THREE.SphereBufferGeometry(3, 32, 32);
              sphereGeometry.scale(-1, 1, 1);
              var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
              scene.add(sphere);
          }
      );  
    }
    loadSphere(backgroundUrl);
    
    renderer.render(scene, camera);
    
    // Events
        
    var raycaster = new THREE.Raycaster();
    var mouse = new THREE.Vector2();
    function onMouseClick(event) {
        raycaster.setFromCamera(mouse, camera);
        if (raycaster.intersectObject(navigationForward).length > 0){
            console.log("Forward Selected");
            @(position = Model.Images.FirstOrDefault(i => i.Position == position).Forward);
        }
        else if (raycaster.intersectObject(navigationBackward).length > 0){
            console.log("Backward Selected");
            @(position = Model.Images.FirstOrDefault(i => i.Position == position).Backward);
        }
        else if (raycaster.intersectObject(navigationLeft).length > 0){
            console.log("Left Selected");          
            @(position = Model.Images.FirstOrDefault(i => i.Position == position).Left);
        }
        else if (raycaster.intersectObject(navigationRight).length > 0){
            console.log("Right Selected");          
            @(position = Model.Images.FirstOrDefault(i => i.Position == position).Right);
        }
        
        hasForward = @(Model.Images.FirstOrDefault(i => i.Position == position).Forward != null);
        hasBackward = @(Model.Images.FirstOrDefault(i => i.Position == position).Backward != null);
        hasLeft = @(Model.Images.FirstOrDefault(i => i.Position == position).Left != null);
        hasRight  = @(Model.Images.FirstOrDefault(i => i.Position == position).Right != null);
        
        if (hasForward){
            navigationForward.visible = true;
        }
        else{
            navigationForward.visible = false;
        }
        
        if (hasBackward){
            navigationBackward.visible = true;
        }
        else{
            navigationBackward.visible = false;
        }
        
        if (hasLeft){
            navigationLeft.visible = true;
        }
        else{
            navigationLeft.visible = false;
        }
        
        if (hasRight){
            navigationRight.visible = true;
        }
        else{
            navigationRight.visible = false;
        }
        
        backgroundUrl = '@("/img/" + Model.Images.FirstOrDefault(i => i.Position == position).ImageName)';
        loadSphere(backgroundUrl);
        
        renderer.render(scene, camera);
    }    
    function onMouseMove(event) {
        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / window.innerHeight) * 2 + 1 + 2 * (56 / window.innerHeight);
    }
    
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    window.addEventListener('mouseup', onMouseClick, false);
    window.addEventListener('mousemove', onMouseMove,  false);
    window.addEventListener('resize', onWindowResize, false);
</script>